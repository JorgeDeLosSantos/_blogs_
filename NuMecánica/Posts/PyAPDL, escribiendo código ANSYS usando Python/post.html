<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body>
<h1 id="pyapdl-escribiendo-código-ansys-apdl-usando-python">PyAPDL, escribiendo código ANSYS APDL usando Python</h1>
<p><a href="https://larysa-tech.blogspot.mx/p/pyapdl.html">PyAPDL</a> es una librería escrita en Python aún en desarrollo, cuyo objetivo es tener la posibilidad de escribir código APDL (ANSYS Parametric Design Language) usando Python.</p>
<h3 id="por-qué-escribir-código-python-y-no-directamente-apdl">¿Por qué escribir código Python y no directamente APDL?</h3>
<p>Hay muchas cosas que son más sencillas en un lenguaje de alto nivel como Python, escribir bucles, definir funciones, crear arreglos, y también la posibilidad de introducir una sintaxis que resulte un poco más descriptiva que la usada nativamente por APDL.</p>
<p>Por ejemplo, para definir un keypoint en las coordenadas (0,0,0) en APDL se tendría:</p>
<pre><code>K,1,0,0,0</code></pre>
<p>Luego, utilizando PyAPDL:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">create_keypoint(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>)</code></pre></div>
<p>Y bien, por ahora la diferencia consiste en la sintaxis utilizada, normalmente y basándonos en buenas prácticas de programación siempre es preferible tener un nombre autodescriptivo para las variables, subrutinas, funciones, clases o cualquier otra porción de código en cuestión, así diríamos que <code>create_keypoint</code> es más descriptivo que <code>K</code>.</p>
<p>Lo anterior está bien, pero Python además nos facilita algunas tareas mediante las estructuras de datos disponibles (diccionarios, tuplas, listas...). Por ejemplo, supongamos que se necesitan crear cuatro keypoints que definan un cuadrado unitario, con PyAPDL haríamos algo como lo siguiente:</p>
<pre><code>kps = {1:(0,0,0),
       2:(1,0,0),
       3:(1,1,0),
       4:(0,1,0)}

for kp in kps:
    create_keypoint(kp, kps[kp])</code></pre>
<h3 id="instalación-y-requerimientos">Instalación y requerimientos</h3>
<p>Para utilizar PyAPDL es necesario tener instalados:</p>
<ul>
<li>Python 2.X / 3.X</li>
<li>NumPy</li>
</ul>
<p>Posteriormente puede seguir las instrucciones que se detallan en el <a href="https://github.com/JorgeDeLosSantos/pyapdl">repositorio en GitHub</a> para instalar de manera correcta la librería.</p>
</body>
</html>
